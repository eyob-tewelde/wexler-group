import numpy as np
from pymatgen.core.surface import SlabGenerator
from pymatgen.io.vasp.outputs import Oszicar, Outcar, Vasprun, Poscar

def match_slabs(slabs):
    """
    Checks to see if there are any matching slabs generated by SlabGenerator

    Parameters:
        slabs: list of Slab
            A list that contains the slabs generated by SlabGenerator

    Returns:
        bool and tup of int:
            If there are matching slabs in the list, the indices of the matching slabs are returned.
            If no matching slabs, returns False
    """
    matches=[]
    match_identities=[]
    for i in range(len(slabs)):
        for j in range(len(slabs)):
            if i != j:
                val = slabs[i].matches(slabs[j])
                if val:
                    matches.append(slabs[i].matches(slabs[j]))
                    match_identities.append((i, j))
    

    if True in matches:
        return match_identities
    else:
        return False
    

def polar_slabs(slabs):
    """
    Checks to see if any of the slabs generated by SlabGenerated are polar
    
    Parameters:
        slabs: list of Slab
            A list that contains the slabs generated by SlabGenerator

    Returns:
        bool and tup of int:
            If there are polar slabs in the list, the indices of the polar slabs are returned.
            If no polar slabs, returns False
    """
    polar_slabs = []
    for i, slab in enumerate(slabs):
        if slab.is_polar():
            polar_slabs.append(i)

    if polar_slabs != []:
        return polar_slabs
    else:
        return False
    

def symmetric_slabs(slabs):
    """
    Checks to see if any of the slabs generated by SlabGenerated are symmetric
    
    Parameters:
        slabs: list of Slab
            A list that contains the slabs generated by SlabGenerator

    Returns:
        bool and tup of int:
            If there are non-symmetric slabs in the list, the indices of the non-symmetric slabs are returned.
            If all slabs are symmetric, returns False
    """
    non_symmetric_slabs = []
    for i, slab in enumerate(slabs):
        if not slab.is_symmetric():
            non_symmetric_slabs.append(i)

    if non_symmetric_slabs != []:
        return non_symmetric_slabs
    else:
        return False


def vac_converge(contcar, miller_index, max_vacuum_size):
    """
    Generates slabs for a given structure and Miller index for a range of vacuum sizes

    Parameters:
        contcar:
        miller_index:
        max_vacuum_size:
    Returns:

    """
    vac_size_slabs = []
    for i in range(1, max_vacuum_size):
        slabgen = SlabGenerator(contcar, miller_index, 10, i) # Structure, Miller index, minimum slab size, minimum vacuum size
        slabs = slabgen.get_slabs(symmetrize=True) # Generate surfaces with a Miller index of (0, 0, 1)
        vac_size_slabs.append(slabs)
    
    num_terminations = len(vac_size_slabs[0])
    terminations = {}
    for i in range(num_terminations):
        terminations[f"{i + 1}"] = []
        for vac_size in vac_size_slabs:
            terminations[f"{i + 1}"].append(vac_size[i])
    
    for key, value in terminations.items():
        c_param = 0
        for vac_size in value:
            if vac_size.lattice.c != c_param:
                c_param = vac_size.lattice.c
                vac_size = Poscar(vac_size)
                vac_size.write_file(filename=f"{miller_index[0]}{miller_index[1]}{miller_index[2]}_{key}_term_vac.POSCAR", direct=False)


def surface_energy(surface_area, e_slab, e_bulk, n_slab):
    """
    Calculates the surface energy of slab

    Parameters:
        surface_area:
        e_slab:
        e_bulk:
        n_sla:
    Returns:

    """
    coeff = 1 / 2 * surface_area
    return coeff * (e_slab - n_slab * e_bulk)